"""Data models and schemas for recipe recommendation service.

Defines Pydantic models for request/response validation and domain objects.
All models use Pydantic v2 for strict validation and OpenAPI schema generation.
"""

from typing import List, Optional
from pydantic import BaseModel, Field


class RecipeRequest(BaseModel):
    """Request schema for recipe recommendations.
    
    Validates incoming requests with ingredient list and optional preferences.
    """
    ingredients: List[str]
    diet: Optional[str] = None
    cuisine: Optional[str] = None
    meal_type: Optional[str] = None
    intolerances: Optional[str] = None


class Ingredient(BaseModel):
    """Domain model for a detected ingredient.
    
    Represents an ingredient extracted from an image with confidence score.
    """
    name: str
    confidence: float


class Recipe(BaseModel):
    """Domain model for a recipe.
    
    Represents a complete recipe with structured ingredients, instructions, and metadata.
    Designed for API responses and structured data handling.
    """
    title: str = Field(..., description="Recipe name or title")
    description: Optional[str] = Field(None, description="Brief description of the dish")
    ingredients: List[str] = Field(..., description="List of required ingredients with quantities")
    instructions: List[str] = Field(..., description="Step-by-step cooking instructions")
    prep_time_min: int = Field(..., description="Preparation time in minutes", ge=0)
    cook_time_min: int = Field(..., description="Cooking time in minutes", ge=0)
    source_url: Optional[str] = Field(None, description="URL to original recipe source")


class RecipeResponse(BaseModel):
    """Response schema for recipe recommendations.
    
    Contains structured recipes, detected ingredients, session metadata, and the LLM-generated response.
    The 'response' field is generated by the LLM and contains conversational text including:
    - Greeting/context
    - Formatted recipe details (if recipes found)
    - Any guardrails, follow-up questions, or suggestions
    
    The 'reasoning' field provides transparency about agent decisions.
    """
    response: str = Field(
        ...,
        description="Conversational response from the LLM including recipe details, guardrails, and follow-ups"
    )
    recipes: List[Recipe] = Field(
        default_factory=list,
        description="List of recipe objects with structured data (up to MAX_RECIPES)"
    )
    ingredients: List[str] = Field(
        default_factory=list,
        description="List of detected or provided ingredients"
    )
    preferences: dict[str, str] = Field(
        default_factory=dict,
        description="User preferences extracted from conversation (diet, cuisine, meal_type, etc.)"
    )
    reasoning: Optional[str] = Field(
        None,
        description="Explanation of agent's decision-making process (why these recipes, guardrails applied, etc.)"
    )
    session_id: Optional[str] = Field(None, description="Session identifier for conversation continuity")
    run_id: Optional[str] = Field(None, description="Unique ID for this agent execution")
    execution_time_ms: int = Field(..., description="Total execution time in milliseconds", ge=0)


class IngredientDetectionOutput(BaseModel):
    """Output schema for ingredient detection tool.
    
    Contains detected ingredients with confidence scores and description.
    """
    ingredients: List[str]
    confidence_scores: dict[str, float]
    image_description: Optional[str] = None
