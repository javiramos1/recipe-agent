"""Data models and schemas for recipe recommendation service.

Defines Pydantic models for request/response validation and domain objects.
All models use Pydantic v2 for strict validation and OpenAPI schema generation.
"""

from typing import List, Optional, Annotated
from pydantic import BaseModel, Field, field_validator, model_validator, ConfigDict


class RecipeRequest(BaseModel):
    """Request schema for recipe recommendations.
    
    Validates incoming requests with ingredient list and optional preferences.
    Enforces constraints on ingredient count, string lengths, and format.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    ingredients: Annotated[List[str], Field(
        min_length=1,
        max_length=50,
        description="List of ingredients (1-50 items, each 1-100 chars)"
    )]
    diet: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=50,
        description="Dietary preference (e.g., vegetarian, vegan, gluten-free)"
    )]
    cuisine: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=50,
        description="Cuisine preference (e.g., Italian, Asian, Mexican)"
    )]
    meal_type: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=50,
        description="Meal type (e.g., breakfast, lunch, dinner, dessert)"
    )]
    intolerances: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=100,
        description="Comma-separated allergies/intolerances (e.g., peanuts, dairy, gluten)"
    )]
    
    @field_validator('ingredients', mode='after')
    @classmethod
    def validate_ingredients(cls, v: List[str]) -> List[str]:
        """Validate ingredients list: non-empty strings, max length 100 chars each."""
        validated = []
        for ing in v:
            if not isinstance(ing, str):
                raise ValueError(f'Each ingredient must be a string, got {type(ing).__name__}')
            ing_stripped = ing.strip()
            if not ing_stripped:
                raise ValueError('Ingredients cannot be empty strings')
            if len(ing_stripped) > 100:
                raise ValueError(f'Ingredient too long (max 100 chars)')
            validated.append(ing_stripped)
        
        return validated


class Ingredient(BaseModel):
    """Domain model for a detected ingredient.
    
    Represents an ingredient extracted from an image with confidence score.
    Enforces valid confidence scores (0.0-1.0) and non-empty ingredient names.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    name: Annotated[str, Field(
        min_length=1,
        max_length=100,
        description="Ingredient name (1-100 chars)"
    )]
    confidence: Annotated[float, Field(
        ge=0.0,
        le=1.0,
        description="Confidence score (0.0-1.0)"
    )]


class Recipe(BaseModel):
    """Domain model for a recipe.
    
    Represents a complete recipe with structured ingredients, instructions, and metadata.
    Designed for API responses and structured data handling.
    Enforces constraints on all fields for data integrity.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    title: Annotated[str, Field(
        min_length=1,
        max_length=200,
        description="Recipe name or title (1-200 chars)"
    )]
    description: Annotated[Optional[str], Field(
        None,
        max_length=500,
        description="Brief description of the dish (max 500 chars)"
    )]
    ingredients: Annotated[List[str], Field(
        min_length=1,
        max_length=100,
        description="List of required ingredients with quantities (1-100 items)"
    )]
    instructions: Annotated[List[str], Field(
        min_length=1,
        max_length=100,
        description="Step-by-step cooking instructions (1-100 steps)"
    )]
    prep_time_min: Annotated[int, Field(
        ge=0,
        le=1440,
        description="Preparation time in minutes (0-1440, i.e., 0-24 hours)"
    )]
    cook_time_min: Annotated[int, Field(
        ge=0,
        le=1440,
        description="Cooking time in minutes (0-1440, i.e., 0-24 hours)"
    )]
    source_url: Annotated[Optional[str], Field(
        None,
        max_length=500,
        pattern=r'^https?://',
        description="URL to original recipe source (must start with http:// or https://)"
    )]


class RecipeResponse(BaseModel):
    """Response schema for recipe recommendations.
    
    Contains structured recipes, detected ingredients, session metadata, and the LLM-generated response.
    The 'response' field is generated by the LLM and contains conversational text including:
    - Greeting/context
    - Formatted recipe details (if recipes found)
    - Any guardrails, follow-up questions, or suggestions
    
    The 'reasoning' field provides transparency about agent decisions.
    Enforces constraints on all fields for API consistency.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    response: Annotated[str, Field(
        min_length=1,
        max_length=5000,
        description="Conversational response from the LLM (1-5000 chars)"
    )]
    recipes: Annotated[List[Recipe], Field(
        default_factory=list,
        max_length=50,
        description="List of recipe objects (max 50 recipes)"
    )]
    ingredients: Annotated[List[str], Field(
        default_factory=list,
        max_length=100,
        description="List of detected or provided ingredients (max 100)"
    )]
    preferences: Annotated[dict[str, str], Field(
        default_factory=dict,
        description="User preferences (diet, cuisine, meal_type, etc.)"
    )]
    reasoning: Annotated[Optional[str], Field(
        None,
        max_length=2000,
        description="Explanation of agent's decision-making (max 2000 chars)"
    )]
    session_id: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=100,
        description="Session identifier for conversation continuity"
    )]
    run_id: Annotated[Optional[str], Field(
        None,
        min_length=1,
        max_length=100,
        description="Unique ID for this agent execution"
    )]
    execution_time_ms: Annotated[int, Field(
        ge=0,
        le=300000,
        description="Execution time in milliseconds (0-300000, i.e., 0-5 min)"
    )]


class IngredientDetectionOutput(BaseModel):
    """Output schema for ingredient detection tool.
    
    Contains detected ingredients with confidence scores and description.
    Enforces strict validation on confidence scores and ingredient format.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    ingredients: Annotated[List[str], Field(
        min_length=1,
        max_length=50,
        description="List of detected ingredients (1-50 items)"
    )]
    confidence_scores: Annotated[dict[str, float], Field(
        description="Confidence scores for each ingredient (0.0 < score < 1.0)"
    )]
    image_description: Annotated[Optional[str], Field(
        None,
        max_length=500,
        description="Natural language description of the image (max 500 chars)"
    )]
    
    @field_validator('confidence_scores', mode='before')
    @classmethod
    def validate_confidence_scores(cls, v: dict) -> dict:
        """Validate confidence scores: each value must be 0.0 < score < 1.0."""
        if not isinstance(v, dict):
            raise ValueError('confidence_scores must be a dictionary')
        
        validated = {}
        for ingredient, score in v.items():
            if not isinstance(ingredient, str):
                raise ValueError(f'Confidence score keys must be strings')
            
            try:
                f = float(score)
            except (ValueError, TypeError):
                raise ValueError(f'Confidence score must be numeric for {ingredient}')
            
            if not (0.0 < f < 1.0):
                raise ValueError(f'Confidence score must be 0.0 < score < 1.0, got {f} for {ingredient}')
            
            validated[ingredient.strip().lower()] = f
        
        return validated
    
    @model_validator(mode='after')
    def validate_scores_match_ingredients(self) -> 'IngredientDetectionOutput':
        """Validate that all ingredients have confidence scores."""
        ingredient_set = set(ing.lower() for ing in self.ingredients)
        score_keys = set(key.lower() for key in self.confidence_scores.keys())
        
        # Allow scores to have extra entries, but all ingredients must have scores
        missing_scores = ingredient_set - score_keys
        if missing_scores:
            raise ValueError(f'Missing confidence scores for: {missing_scores}')
        
        return self
